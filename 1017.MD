# 정보보안
__________________


### 단순 인증 절차

#### 첫 번째 가상 절차

인증서버(AS) 이용 : AS는 각 비밀키를 이용

1) 클라가 첫번째 AS에세 아이디, 패스워드, 서버 식별자를 제공
2) AS는 클라에게 티켓을 줌
3) 클라는 V에게 ID와 티켓을 줌

티켓 = ( 키값, (클라ID, 클라네떡주소, 서버식별자) )


* 검증 문제
시스템 적으로 암호화를 한다면 서버에서 어떻게 검증? -> 패스워드를 어떻게 저장해 놓을까? -> 암호화해서 저장하지 말고 시스템 입장에서 본다면 해싱을 해서 저장을 해서 아이디와 패스워드를 보내면 해싱을 해서 해싱값만 비교

서버 아이디 보내는 이유 : 다른 서버에게 주는걸 막기 위해
클라이언트 네떡 주소 사용 이유 : ID사칭 방어, 


* 그외 추가적인 문제
패스워드 평문 전송 문제, 입력 패스워드 수 과다

티켓을 가로챈 뒤 워크스테이션에서 로그오프할때까지 대기하고
-> 주소를 조작해서 네떡주소까지 사팅
-> 티켓을 재사용

==> 티켓에 타임스탬프, 유효시간 표기


#### 두번째 가상절차

* 사용자 로그온 세션마다 한번
1) 클라가 AS에게 클라 아이디, 티켓 서버(TGS) 아이디를 보냄
2) AS는 클라에게 공유키랑 TGS 티켓을 보냄

* 서비스 유형마다 한번
3) 클라는 TGS에게 클라아이디, 서버 아이디, TGS티켓을 줌
4) TGS는 클라에게 서버 티켓을 줌

* 서비스 세션마다 한번
5) 클라는 서버에게 클라아이디, 서버티켓을 줌

TGS티켓 = E(Ktgs, [IDC, ADC, ADC, IDtgs, TS1, Lifetime1])
V티켓 = E(Kv, [IDC, ADC, ADC, IDv, TS2, Lifetime2])

※ TS = 타임스탬프, Lifetume = 유효기간


===> 첫 번째 시나리오 보다는 안전하지만, 여전히 문제 존재

1) 티켓-승인 티켓의 유효기간 적절 조정 문제(티켓 사용자와 발행자가 동일 인물임을 증명)
-> 유효기간 로그오프 지점을 파고들어서 접근할 수 있음 유효기간을 틈이 없게 조정해야 함

2) 서버가 사용자에게 자신을 인증할 필요가 있음
-> 금융기관 사칭과 같은 문제


#### 더욱 개선된 방법
클라, 서버, AS만 알고있는 세션키를 추가하여 구분

a) 인증서비스 교환 티켓 발행 티켓 취득

1) C -> AS: IDC, IDtgs, TS1
2) AS -> C: E(Kc, [Kc,tgs, IDtgs, TS2, Lifetime2, Tickettgs])

Kc,tgs = 세션키

b) 티켓-발행 서비스 교환: 서비스-발행간의 통신
C -> TGS: IDv, Tickettgs, A

c) 티켓-발행 서비스 교환: 서비스 취득(서버가 자신을 인증)


클라와 서버가 공유하는 세션키를 이용하여 검증, 클라 ID 대신 세션키를 이용해 외부에서 사칭 어려움
세션키를 모르면 TS5를 풀 수 없는 점을 이용하여 TS5+1을 보내어 인증

위에거 다음, 버전5 이전 그림
커버로스 관련 그림만 잘 봐두기!!

_________________
# 프로그래밍언어론
__________________


### 구문과 프로그래밍 신뢰성

* 현수 else 문제
if else 에는 then 이라는 키워드가 원래는 있어야 된다고 생각, else절 생략 가능
if문을 사용할때 중첩 if문을 사용할 수 있음 else 절을 구분하는게 어려움 -> 가장 가까운 if의 else로 규정

* 각 언어에서의 현수 else 문제 해결
Algol 60 : begin-end(괄호역할)을 추가
Algol 68 : fi 추가
PL/I : 세미콜론을 통해 구분
Pascal : begin-end(괄호역할)을 추가

### 프로그래밍 언어 구현 기법
번역기법, 인터프리터 기법

번역기 : 소스코드를 집어 넣어서 타겟프로그램으로 만들어줌

컴파일러, 어셈블러, 링커, 로더, 인터프리터

로드가 하는 역할 = 하드디스크에 있는 실행 파일을 가져와주는 역할 디스크->메모리
로드 모듈 = 실행 파일(exe)

* 번역기법의 종류
1) 컴파일러 : 고급언어 -> 저급언어
2) 어셈블러 : 어셈블리 언어 -> 준기계어 형태(상대주소)
3) 링케이지 에디터 : 여러 개의 프로그램 -> 로드 모듈(실행파일)
4) 로더 : 기계어 프로그램(로드 모듈) -> 실행가능한 완벽한 기계어(절대주소)를 메모리에 적재
5) 프리프로세서 : 고급언어 -> 고급언어 (전처리기) 메크로(#define) 적용, 헤더파일의 내용을 읽어서 복사/붙여넣기와 같이 C -> C또한 포함되고 C -> JAVA와 같이 다른 언어로 바꿀수도 있음
ex ) JAVA 파일을 C환경에서 테스팅

* 인터프리터 기법

문법검사만 한 후에 소프트웨어가 실행, 즉각적 테스팅이 가능 but 느림
1+3을 CPU가 동작하지 않고, 인터프리터 프로그램이 실행 -> 시뮬레이터 개념
번역을 하지 않기 때문에 exe파일이 남지 않음
매번 문법검사를 해야하기 때문에 exe파일을 남기는 번역기법에 비해 매우 느림
개발 단계에서는 즉각 실행이 가능하기 때문에 편리함


* 인터프리터와 번역 기법의 비교
번역기 : 목적프로그램 생성, 높은 효율성, 번역된 프로그램이 큰 기억 장치 요구
인터프리터 : 직접 입력 프로그램을 실행, 유연한 사용(코딩, 이해, 테스팅 용이)



함수를 썼다는 개념은 기계어가 아닌 논리적인 simulation 한다는 느낌으로 간다.
순수 번역 기법이나 순수 시뮬레이션 기법은 실제로 거의 존재하지 않음


* 하이브리드 기법
1) 프로그램을 실행시키기 편한 형태로 번역하고, 시뮬레이션으로 실행
2) 또는 번역기와 인터프리트를 동시 제공

* 컴파일러 언어와 인터프리터 언어 종류
컴파일러 : Fortran, Algol, PL/I, Pascal, Cobol, C, Ada
인터프리터 언어 : Lisp, SNOBOL4, APL, Prolog
APL : 순수 인터프리터 언어



## 5장 컴파일러 개요

### 컴파일러 일반적 구성

* 컴파일러
 : 고급 언어 원시 코드 프로그램 -> 목적 프로그램(어셈블리 언어 or 기계어)
ex) C 컴파일러 on SPARC : C프로그램을 SPARC에서 수행가능한 코드로 출력

IBM 호환 PC

* 컴파일러 구조
나누는 기준 : 하드웨어에 따라 달라질 수 있는가???, CPU의 종류에 따라서 기계어가 다르기 때문에 맞추어 주어야 함

Front-End : 수학적 개념 이용
Back-End : 경혐적 개념 이용(패턴 매칭)

* Front-End
Lexial analysis(어휘 분석) : 일련의 토큰의 나열(토큰 스트림)으로 출력
Syntax analysis(구문 분석)(문법 검사) : 잘라준 토큰들을 문법 검사
Semantic analysis(의미 분석) : 구문별로 숫자화 해서 출력
Intermediate code generation(중간 코드 생성) : 의미 분석한 결과를 중간 코드로 출력


* Back-End
Code optimization(코드 최적화)
Code generation : 코드 생성, 기계어와 유사한 코드로 만들어 출력

* Lexial analysis
컴파일러 내부에서 효율적이며 다루기 쉬운 정수로 바꾸어 줌

* Syntax analysis(Parser)
파싱
문법 검사, 트리 생성(간략화된 트리로 표현하여 저장)
문법 검사에 맞지 않으면 에러, 맞으면 트리 형태 출력


* Intermediate code generation
중간 코드 생성


* Code Optimizer
비효율적인 code를 구분해 내서 더 효율적인 code로 바꾸어 준다. ex) 2*2같은 코드를 2*2 => 2+2 => 4

3가지 주요 요소
1) 프로그램 의미를 지켜야 한다.
2) 평균 속도가 늘어야 한다.
3) 최적화 한 만큼 가치가 있어야한다.


Global optimization : 프로그램 전체 최적화 (안쓰는 코드 번역 X)
Local optimization : 2*2같이 지역적인 최적화



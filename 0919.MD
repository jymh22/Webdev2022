# 정보보안
------------


## 2. 대칭 암호 알고리즘

* DES - 56bit
* 3중 DES - 162bit
* AES - 64, 128, 256 bit


#### 대칭 블록 암호 설계 요소

* 블록길이 : 주로 64비트. 요즘은 더 높음.
* 키길이 : 보편적 128비트. 길이가 길수록 보안업, 성능다운.
* 라운드수 : 전형적 16라운드
* 서브키 생성 알고리즘 : 복잡할수록 암호해독이 어려워진다.
* 라운드 함수 : 복잡할수록 암호해독이 어려워진다.


#### 대칭 블록 암호 설계시 고려 사항
* 빠른 소프트웨어 암호화 복호화
 암호화에 오래걸리면 사용성 저하

* 용이한 해독
 알고리즘을 간결하고 명확하게 설명할 수 있어야 한다
 취약성 분석이 쉬워지므로 개선 또한 쉬워진다.


#### DES

 과거부터 자주 쓰이던 대칭 블록 암호
 옛날 컴퓨터 기술로는 매우 오랜 시간이 걸렸지만 컴퓨터가 발전한 요즘은 보안성이 약해짐
 


#### 3중 DES

 DES가 보안에 취약해지자, AES를 써야 하는 상황이 왔는데, 이미 DES로 짜여진 시스템을 바꾸기에는 비용이 너무 많이 들어 DES를 3번 거듭하는 것으로 암호화
56 * 3 = 162bit
암호 - 복호 - 암호 순서로 수행하게 됨, C= E(K3D(K2E(K1P)))


#### AES

* 3DES는 느리고 64블록을 사용하므로 블록 사이즈가 커야 한다.
* 3DES가 장기적으로는 부적합하다.
* AES 암호화의 경우 128비트 또한 양자컴퓨터로도 해독에 매우 오랜 시간이 걸린다. (보안성이 높다)

 위와 같은 이유로 보AES가 대두됨
------------



# 프로그래밍 언어
------------


##프로그래밍 언어의 역사

CPL -> BCPL -> B -> C
Combined Programing Language


#### 1950 초반

* 기계어 사용


#### 1950 중반

* FORTRAN
 최초의 고급 언어
 효율적인 기계어 코드 생성 -> 긴 생명
 배열, 반복 구조, 분기문, 부프로그램 등의 특징은 이후 언어에 큰 영향


#### 1950 후반

* COBOL : 상업자료처리용(단순 사칙연산)
* ALGOL 60(ALGOrithmic Language 60) : 알고리즘 기술, 법용
* LISP(LISt Processor) : 기호연산, 리스트 처리용(괄호가 어마어마어마하게 많음), 수학적 함수 유리 ex)인공지능, 로봇
* APL(A Programing Language)(프로그래밍 언어중 최고라는 뜻) : 배열 처리용, 인터프리터(고급 언어와 반대적 성격)


#### 1960년대(프로그래밍 언어의 폭증 시대)

* PL/I
 병행성, 기억 장소 할당, 예외처리와 같은 새로운 개념 추가

* Algol68
 Algol60 + 타 언어의 여러 기능 + 표현력 있고 일관된 구조
 디자인 일관성, 파일 시스템, 실행 환경이 우수 but 범용 컴퓨터 사용 불가능

#### 1960 기타 특이한 언어

* Snobol(StriNg Oriented Language) : 문자열 처리 특화 언어
* Simula67 : 객체지향, 클래식 개념을 최초 도입, 시뮬레이션 목적
* Basic : 배우기 매우 쉽게 만든 언어


#### 1970 초반(간결성, 일관성 추구)

* C
* Pascal

-> C, Pascal : 간결성, 일관성을 잘 유지


#### 1970 중반

* CLU : 추상화 기법 사용 class와 유사
* Euclid : Pascal 개선
* Mesa


#### 1980 년대

* Ada
 자료 추상화, 타입 메커니즘, 병행 처리, 예외처리기 도입
 복잡하고 방대해서 슈퍼컴퓨터에서 사용

* Modula-2
 Pascal의 디자인에 결점 보완(실험적 언어)
 임베디드 시스템 목적


#### 1980년대

* C++ : C언어 + 객체지향
* Eiffel : Pascal에 가까우면서 객체지향 언어
* 함수형 언어 등장


#### 1990년대

* 웹언어 HTML, Java 등장
* Java : 간결성과 신뢰선 제공 원칙


#### 프로그래밍 언어의 세대 구분

> 제 1세대 : 어셈블리 언어
> 제 2세대 : 비구조형 언어
> 제 3세대 : 구조형 고급 언어
> 제 4세대 : 화일처리(SQL)
> 제 5세대 : 초 고급 언어

         or

> 제 1세대 : 기계어
> 제 2세대 : 어셈블리 언어
> 제 3세대 : 고급 언어
> 제 4세대 : 화일처리(SQL)
> 제 5세대 : 초 고급 언어

※ 화일처리 언어 : 몇개 안되는 코드로 


#### 소프트웨어 위기 극복

* 언어 기술 보다는 조직적인 방법으로 해결
 기존 코드의 재사용 증대
 이식성 증대
 문법 위주의 에디터를 사용하여 생산성 증대

* 언어 설계의 미래
 하드웨어와 컴퓨터 구조의 발달에 의해 영향 받음




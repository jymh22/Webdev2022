# 프로그래밍 언어
------------

## 1장 프로그래밍 언어 소개  
* 컴퓨터에 대한 이해와 활용
* 컴퓨터가 발전함에 따라 프로그래밍 언어또한 변화함

#### 프로그래밍 언어의 정의
* 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로 계산을 기술하는 표현체계

#### 프로그래밍 언어를 배워야 하는 이유
* 사용하고 있는 언어의 이해와 효율적인 알고리즘 작성
* 유용한 프로그래밍 구사 능력
* 프로그래밍 언어 선택 능력

#### 프로그래밍 언어에서의 추상화
* 추상화의 개념 : 주어진 작업이나 객체를 속성들의 일부분을 가지고 필요한 만큼 묘사할 수 있는 방법을 지원하는 것

#### 추상화의 범주
* 자료 추상화 : 문자열, 수, tree와 같은 계산될 자료의 특성을 추상화
* 제어 추상화 : 실행 순서를 제어하는 특성을 추상화

#### 추상화 분류
* 기본 추상화 : 가장 지역적인 기계 정보에 대한 추상화
* 구조 추상화 : 보다 전역적인 정보인 프로그램의 구조에 대한 추상화
* 단위 추상화 : 단위 프로그램 전체에 대한 정보의 추상화


#### 자료 추상화
* 컴퓨터 내부의 자료 표현을 추상화
* 관련된 자료의 집합을 추상화
* 전형적인 구조 추상화 예 : 배열, 레코드 (구조형 자료)
* 구조형에 새 이름 부여 기능(새 차원의 추상화)
* 자료의 생성과 사용에 대한 정보를 한 장소에 모아두고, 자료의 세부사항에 대한 접근을 제한하는 도구

#### 제어 추상화
* 몇 개의 기계 명령어를 모아 이해하기 쉬운 추상 구문으로 만드는 것
* 프로그램에서 어떤 검사된 값에 따라 분할된 명령어의 한 그룹을 수행
* 프로시저의 집합을 추상화 (관련된 프로시저 그룹 추상화), library 형태 지원


#### 계산 전형
* 프로그래밍 언어는 컴퓨터의 계산을 모방하는 데서 비롯됨

> 함수형 언어 : 함수의 평가 및 호출 방법 제공(Modula-2, LISP)
> 논리형 언어(선언적 언어) : 기호 논리학에 근거 계산의 내용만 기술(Prolog)
> 객체지향 언어 : 기억장치 기억장소와 이 기억장소의 값을 변경할 수 있는 연산의 집합(Simular 67, C++, Ada)

#### 언어 정의
* 언어에 대한 정확한 형식 기술 방법이 필요
* 프로그래밍 과정에서 프로그램 동작의 이해를 위해 필요
* 구문론(Syntax)와 의미론(Semantics)으로 구분

#### 프로그래밍 언어의 정확한 형식 정의가 필요한 이유
* 언어의 구조와 의미의 정확한 기술 없이는 프로그래밍이 불가능
* 모호함 없는 언어 구현
* 프로그래밍 과정에서 프로그램이 어떻게 동작할 것인가에 대한 문제 발생 시 유용
* 프로그램 설계 과정을 규격화하는 방법




## 2장 언어의 변천

CPL -> BCPL -> B -> C
Combined Programing Language


#### 1950 초반

* 기계어 사용


#### 1950 중반

* FORTRAN
 최초의 고급 언어
 효율적인 기계어 코드 생성 -> 긴 생명
 배열, 반복 구조, 분기문, 부프로그램 등의 특징은 이후 언어에 큰 영향


#### 1950 후반

* COBOL : 상업자료처리용(단순 사칙연산)
* ALGOL 60(ALGOrithmic Language 60) : 알고리즘 기술, 법용
* LISP(LISt Processor) : 기호연산, 리스트 처리용(괄호가 어마어마어마하게 많음), 수학적 함수 유리 ex)인공지능, 로봇
* APL(A Programing Language)(프로그래밍 언어중 최고라는 뜻) : 배열 처리용, 인터프리터(고급 언어와 반대적 성격)


#### 1960년대(프로그래밍 언어의 폭증 시대)

* PL/I
 병행성, 기억 장소 할당, 예외처리와 같은 새로운 개념 추가

* Algol68
 Algol60 + 타 언어의 여러 기능 + 표현력 있고 일관된 구조
 디자인 일관성, 파일 시스템, 실행 환경이 우수 but 범용 컴퓨터 사용 불가능

#### 1960 기타 특이한 언어

* Snobol(StriNg Oriented Language) : 문자열 처리 특화 언어
* Simula67 : 객체지향, 클래식 개념을 최초 도입, 시뮬레이션 목적
* Basic : 배우기 매우 쉽게 만든 언어


#### 1970 초반(간결성, 일관성 추구)

* C
* Pascal

-> C, Pascal : 간결성, 일관성을 잘 유지


#### 1970 중반

* CLU : 추상화 기법 사용 class와 유사
* Euclid : Pascal 개선
* Mesa


#### 1980 년대

* Ada
 자료 추상화, 타입 메커니즘, 병행 처리, 예외처리기 도입
 복잡하고 방대해서 슈퍼컴퓨터에서 사용

* Modula-2
 Pascal의 디자인에 결점 보완(실험적 언어)
 임베디드 시스템 목적


#### 1980년대

* C++ : C언어 + 객체지향
* Eiffel : Pascal에 가까우면서 객체지향 언어
* 함수형 언어 등장


#### 1990년대

* 웹언어 HTML, Java 등장
* Java : 간결성과 신뢰선 제공 원칙


#### 프로그래밍 언어의 세대 구분

> 제 1세대 : 어셈블리 언어
> 제 2세대 : 비구조형 언어
> 제 3세대 : 구조형 고급 언어
> 제 4세대 : 화일처리(SQL)
> 제 5세대 : 초 고급 언어

         or

> 제 1세대 : 기계어
> 제 2세대 : 어셈블리 언어
> 제 3세대 : 고급 언어
> 제 4세대 : 화일처리(SQL)
> 제 5세대 : 초 고급 언어

※ 화일처리 언어 : 몇개 안되는 코드로 


#### 소프트웨어 위기 극복

* 언어 기술 보다는 조직적인 방법으로 해결
 기존 코드의 재사용 증대
 이식성 증대
 문법 위주의 에디터를 사용하여 생산성 증대

* 언어 설계의 미래
 하드웨어와 컴퓨터 구조의 발달에 의해 영향 받음



 
## 3장 프로그래밍 언어 설계



#### 언어 성공 요인 및 설계 목적

* 성공 요인
> Fortran : 컴퓨터 제조회사 후원
> Cobol : 미 국방성 지원
> Lisp : 인공지능 분야에서 사용
> Pascal : 교육용, 마이크로컴퓨터 표준언어 역할
> PL/I : IBM의 적극 후원
> C : UNIX 운영체제의 성공
> Ada : 미국방성 지원

* 설계목적
> Fortran : 실행의 효율성
> Cobol : 영어와 유사한 문법 구조로 program의 easy readability
> Algol60 : 블록 구조 제공으로 알고리즘 작성 용이
> Pascal : 간단한 명령형 언어, 하향식 설계 증진



#### 프로그래밍 언어 역사

* 1950년대
 초기 설계기준 : Efficiency of execution ---> Fortran

 이후 Cobol과 Algol 60의 등장 --> 효율성보다 일반적인 원칙 중시

> Algol 60 : 블록구조, 재귀적 용법으로 논리적으로 간결 명료한 알고리즘 표현 용이
> Cobol : 프로그램 판독성 증가 (영어 유사 문법 구조)


* 1960년대
 복잡성 제어(complexity control) 필요성 인식 - 추상화 기법, 언어 규칙과 제한의 감소 필요성

> Simula67 : 강력한 추상화 기법 제공
> Algol68 : 일반성, 직교성 제공으로 언어의 복잡성 감소


* 1970년대 ~ 1980년대 초
 간결성(simplicity)과 추상화(abstraction)를 강조
 언어 구성에 수학적 정의 도입
 프로그램의 정확성 증명 기법을 갖춘 언어 제공 ⇒ 프로그램 신뢰성 증진

> Pascal
> C
> Euclid
> Modula-2
> Ada


* 1980년대
 언어에 논리 또는 수학 개념의 삽입 증진
 논리를 프로그래밍 언어 자체에 포함
 함수형 언어, 객체 지향 언어에 관심 증가

> ML : 함수형 언어
> Miranda : 함수형 언어
> Scheme : 함수형 언어
> C++ : 객체 지향 언어



### 프로그래밍 언어 설계 원칙

* 언어 설계의 기본 원칙
효율성
일반성
직교성
획일성

* 기타 설계 원칙
간결성
안전성
표현력
기존 표기나 규칙과의 일관성
정확성
확장성
기계 독립성
제약성
부분성


### 효율성

#### 효율성 기준에 따른 분류
* 목적 코드의 효율성
 - 번역할 때 효율적인 실행 코드 생성

* 번역의 효율성
 - 적절한 크기의 번역기로 빠르게 번역

* 구현의 효율성
 - 번역기의 효율적 작성 가능 여부

* 프로그래밍 효율성
 - 프로그램 작성의 단순성, 용이성 문제


=> 효율성은 신뢰도와 직결됨



### 일반성
* 특별한 경우를 피하거나 밀접한 관련의 여러 개념들을 하나의 개념으로 결합


#### 일반성이 부족한 경우의 예

* 프로시저
→ Pascal : 프로시저 선언과 매개 변수 허용, 프로시저형 변수 불허
→ Modula-2 : 일반성 보유
→ Ada : 매개 변수에 프로시저 사용 못함

* 배열
→ Pascal : 가변 배열 불허
→ C, Ada : 가변 배열 허용
→ Modula-2, Fortran : 가변 배열 전달능력, 가변배열 선언 불허

* 동등 연산자 , 배정 연산자(=, :=)
→ 대부분 언어 : 배열, 레코드에 적용 불허
→ Ada : 배열, 레코드에 적용 허용

* 매개변수
→ Fortran : call by reference 만 허용
→ Algol 68, C, Java : call by value, 객체에 대한 포인터를 값으로 전달 가능 → 일반성 제공
→ Ada : 일반성 제공


#### 일반성이 갖는 문제점
* 언어의 간결성 저하
* 언어의 판독성 저하
* 언어의 신뢰성 저하




### 직교성
* 수학 개념에서 유래 “직각 또는 완전히 독립적인 방향”
* 언어의 구성자들이 각각의 의미를 가진 채 결합하는 성질
> 비직교성 – 문맥에 의존하는 제한
> 비일반성 – 문맥과 관계없는 제한


#### 직교성이 부족한 경우의 예

* 함수 반환 값 자료형
→ Pascal : 스칼라형, 포인터형만 허용
→ C : 배열형만 제외
→ Ada : 완벽한 직교성 제공 (모든 자료형 허용)

* 파일
→ Pascal : 화일형은 특별한 상태 취급
→ 대부분 언어 : 화일을 라이브러리로 취급 (비직교성 탈피)

* 문자열
→ Modula-2 : 문자열 배정 (작은 문자열 → 더 큰 문자열), 크기가 다른 객체에 대한 유일한 배정

* 매개변수 전달기법
→ C : 배열 - call by reference, 이외 모든 자료형 - call by value 방식
→ Ada : 모든 자료형 - call by value, result, value-result 허용(직교성 보장)




### 획일성
* 언어 구조들의 외모와 행동에서의 조화에 중점을 둠
* 유사한 것들은 유사하게 보이고 유사한 의미를 갖게 하며, 상이한 것들은 서로 다르게 보이고 서로 다르게 행동하여야 된다는 성질

if ~ ?
  do ~
else ?
  do !

와 같이 문맥에 맞는 직관적인 구조



## 4장 프로그래밍 언어의 구문과 구현기법

컴퓨터 시스템 : 프로그램을 저장하고 실행할 수 있는 알고리즘과 자료 구조들의 전역 집합


### 언어 구문

##### 프로그래밍 언어의 기본 문자 집합

* Alphabet 문자 (A-Z) 26개 + 아라비아 숫자 (0 - 9) 10개


* 문자 코드 체계
ex) 아스키 코드, 유니코드


* 정합 순서 : 문자 또는 문자열에 대한 일반적인 순서언어(코드 체계 따름)
 - 문자 또는 문자열에 대한 일반적인 순서언어
 - 언어 구현 시에 결정, 일반적으로 문자의 bit 조합 표현 순서에 영향 (코드 체계 따름)


* 어휘 구조 용어
- 어휘 토큰 : 기본 의미 단위를 표현하는 한 개 이상의 프로그래밍 언어의 알파벳 문자로 구성된 문자열
- 언어 구성자 : 한 개 이상의 어휘 토큰으로 형성되며, 구문적으로 허용된 프로그램의 일부
- 식별자 : 언어 어휘를 구성하는 단어나 기호 형태의 문자 알파벳, 변수 이름으로 사용할 수 없음
- 구분자 = 분리자


#### 1. BNF - EBNF //이전 수업시간 
사용자를 위한 표현 방법

BNF를 다이어그램으로 그림 - 사용자를 위한 표현 방법


#### 2. 구문 도표(Syntax diagram)

구문 도표는 그 형태가 순서도와 유사

구문 도표는 EBNF와 일대일대응

-> 다시 정의될 대상은 box (nonterminal), terminal 기호는 원이나 타원형으로 표시

-> 이들 사이는 지시선으로 연결

terminal : 원으로
nonterminal : 사각형으로 그리는거 봐두기
컴파일러를 위한 문법 표현


#### 3. ParseTree

//트리 -> 문법 표현

//컴파일러가 번역을 할때 문법검사하는 용도로 사용

* 원시 프로그램의 문법 검사 과정에서 내부적으로 생성되는 트리 형태 자료 구조

* 문장 표현이 BNF에 의해 작성될 수 있는지 여부를 나타냄

* nonterminal 언어부터적용

// <letter> | <identifier><letter> <identifier><digit>
  
//첫번째로 시작되는 언어가 숫자가 아닌 문자이어야 함을 의미 
  
// 파스트리에서 문자는 LIFO(스택) 방식으로 읽어냄


* 모호성 발생 : 데이터를 정렬하는 것이 아니므로 순서 적용에 모호함이 생김
  
//-> 트리를 따라가는 방법은 left-parse, right-parse로 표현함

* 선형계단식(precedencecascade; 순위 폭포) : 새 비 단말기호(non-terminal symbol: <term>)와 문법 규칙을 추가하여 문법의 우선순위를 정함
  
// *, /의 우선순위는 +, -보다 높다.

// +와 -의 우선 순위는 동일하므로 좌측 순환으로 처리한다.
  
//+의 경우 좌 결합, 우 결합의 결과값은 같지만 -의 경우 서로 결과값은 달라진다.
  
* 기본적으로 좌측 결합(left-associative)을 전제로 하되, 거듭제곱 (ⁿ)의 경우 우측 결합(right-associative)으로 한다.
  


표 4.5에서 
아래로 내려갈 수록 우선순위를 가짐
<digit> ->  <number><digit> | <digit>


구문과 프로그램 신뢰성(reliability)
구문(Syntax)
언어의 신뢰성에 영향

현수(dangling) else 문제
 -> 중첩된 if  문에서 else는 어떤 if의 else인가?
 예제 : if c1 then if c2 then S1 else S2

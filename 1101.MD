# 정보보안
_________________________

정보보안 시험

## 3장 공개키 암호와 메시지 인증

### 3.5 공개키 암호 알고리즘

RSA

Diffie-Hellman 키교환
 : 두 사용자가 비밀키를 안전하게 교환하여 메시지를 암호화
   이산 대수 문제를 풀기 어렵다는 것에 근거


이산대수문제

소수 p의 원시근 : 거듭제곱을 이용하면 1~p-1까지의 정수를 모두 생성해 낼 수 있는 수

𝑝보다 작은 임의의 정수 𝑏와 𝑝의 원시근 𝑎에 대해서
다음을 만족하는 유일한 지수 𝑖를 찾을 수 있다.
𝑏 = 𝑎
𝑖mod 𝑝,여기서 0 ≤ 𝑖 ≤ 𝑝 − 1


𝑖 = dlog𝑎,𝑝(𝑏) 를 구할수 없을 정도로 p값을 큰 수로 지정


중간자 공격



기타 공개키 암호 알고리즘


디지털 서명 표준 : 서명 기능만 제공
타원 곡선 암호 : 계산속도가 빠르고, RSA와 동등한 안정성




### 3.6 디지털 서명
인증 여부만 넣기 때문에 작은 비트블록

인증자 변경없이 문서 변경X
출처, 내용 순서 확인
메시지 무결성 보장, 기밀성 보장X


DSA 디지털 서명 알고리즘
RSA 디지털 서명 알고리즘
타원곡선 디지털 서명 알고리즘

RSA-PSS 참고용

매번 다른 솔트를 생성하기 때문에 동일한 키를 사용하여도 다른 서명을 생성 -> 보안성 강화




## 4장 네트워크보안 응용

### 4.1 원격 사용자 인증 원칙

사용자 인증 : 주장하는 신원이나 시스템 개체를 검증하는 과정

1. 인증단계
 - 식별 단계 : 보안 시스템 식별자 제시하기
 - 검증 단계 : 개체와 식별자사이의 binding을 입증할 수 있도록 인증 정보 제시 및 생성하기

인증 방법
 1. 개인이 알고있는 것 : 패스워드, PIN번호
2. 개인이 소지하고 있는 것 : 암호 키, 전자 키 카드, 스마크 타드
3. 개인자체(정적 생체정보) : 지문, 망막, 안면
4. 개인이 수행하는 것(동적 생체정보) : 음성 패턴, 타미핑 리듬, 수기한 문자


MFA Multi Factor Authenficatuin
 : 로그인 + 전화번호 인증과 같이 2개 이상의 보안을 조합해서 인증을 강화하는 개념

### 4.2 대칭 암호를 이용한 대칭키 분배
 암호 시스템의 강도는 키를 분배하는 기술적 문제와 결부

125p 1~4 참조

manual delivery : 외국에서 학교에서 키를 받아와서 사용하듯이 지정한 키를 전달하여 사용하는 개념

링크 레벨이 하느 이유는 스위치가 하기 때문이다.


세션키 : 세션이라는 논리적 연결이 유지되는 동안만
영구키 : 영구적 유지, 노출이 많아 보안성 떨어짐, 영구키를 가끔만 사용하는 경우에 주로 사용, 엄청나게 길 수 있음

KDC 카 분배 절차

### 4.3 커버로스(Kerberos)
키 분배, 사용자 인증 프로그램

~네트워킁 대한 위협
분산환경의 3가지 위협 : 다른 사용자로 위장, 네트워크 주소 변경, 재전송 공격
방어수단 : 커버로스 : 서버에 사용자를 인증하고, 


Authenrication Server(AS)
ex) 프린트를 할 때 아이디 패스워드 입력 후 프린트를 하면 학과 프린터실에 프린트가 돼 있음 -> 파일 서버와 통신을 할때 아이티와 패스워드를 넣음
 -> 프린트 서버에 넘어감 -> 할때마다 아이디와 패스워드를 넣어야 하는게 너무 불편 -> 티켓을 가지고 있으면 처음에 아이디/패스워드를 넣은 후 그 다음 그 티켓을 이용해 입력없이 가능

ticket granting ticket TGT 제공

ticket granting Server



### 단순 인증 절차

#### 첫 번째 가상 절차

인증서버(AS) 이용 : AS는 각 비밀키를 이용

1) 클라가 첫번째 AS에세 아이디, 패스워드, 서버 식별자를 제공
2) AS는 클라에게 티켓을 줌
3) 클라는 V에게 ID와 티켓을 줌

티켓 = ( 키값, (클라ID, 클라네떡주소, 서버식별자) )


* 검증 문제
시스템 적으로 암호화를 한다면 서버에서 어떻게 검증? -> 패스워드를 어떻게 저장해 놓을까? -> 암호화해서 저장하지 말고 시스템 입장에서 본다면 해싱을 해서 저장을 해서 아이디와 패스워드를 보내면 해싱을 해서 해싱값만 비교

서버 아이디 보내는 이유 : 다른 서버에게 주는걸 막기 위해
클라이언트 네떡 주소 사용 이유 : ID사칭 방어, 


* 그외 추가적인 문제
패스워드 평문 전송 문제, 입력 패스워드 수 과다

티켓을 가로챈 뒤 워크스테이션에서 로그오프할때까지 대기하고
-> 주소를 조작해서 네떡주소까지 사팅
-> 티켓을 재사용

==> 티켓에 타임스탬프, 유효시간 표기


#### 두번째 가상절차

* 사용자 로그온 세션마다 한번
1) 클라가 AS에게 클라 아이디, 티켓 서버(TGS) 아이디를 보냄
2) AS는 클라에게 공유키랑 TGS 티켓을 보냄

* 서비스 유형마다 한번
3) 클라는 TGS에게 클라아이디, 서버 아이디, TGS티켓을 줌
4) TGS는 클라에게 서버 티켓을 줌

* 서비스 세션마다 한번
5) 클라는 서버에게 클라아이디, 서버티켓을 줌

TGS티켓 = E(Ktgs, [IDC, ADC, ADC, IDtgs, TS1, Lifetime1])
V티켓 = E(Kv, [IDC, ADC, ADC, IDv, TS2, Lifetime2])

※ TS = 타임스탬프, Lifetume = 유효기간


===> 첫 번째 시나리오 보다는 안전하지만, 여전히 문제 존재

1) 티켓-승인 티켓의 유효기간 적절 조정 문제(티켓 사용자와 발행자가 동일 인물임을 증명)
-> 유효기간 로그오프 지점을 파고들어서 접근할 수 있음 유효기간을 틈이 없게 조정해야 함

2) 서버가 사용자에게 자신을 인증할 필요가 있음
-> 금융기관 사칭과 같은 문제


#### 더욱 개선된 방법
클라, 서버, AS만 알고있는 세션키를 추가하여 구분

a) 인증서비스 교환 티켓 발행 티켓 취득

1) C -> AS: IDC, IDtgs, TS1
2) AS -> C: E(Kc, [Kc,tgs, IDtgs, TS2, Lifetime2, Tickettgs])

Kc,tgs = 세션키

b) 티켓-발행 서비스 교환: 서비스-발행간의 통신
C -> TGS: IDv, Tickettgs, A

c) 티켓-발행 서비스 교환: 서비스 취득(서버가 자신을 인증)


클라와 서버가 공유하는 세션키를 이용하여 검증, 클라 ID 대신 세션키를 이용해 외부에서 사칭 어려움
세션키를 모르면 TS5를 풀 수 없는 점을 이용하여 TS5+1을 보내어 인증

위에거 다음, 버전5 이전 그림
커버로스 관련 그림만 잘 봐두기!!
